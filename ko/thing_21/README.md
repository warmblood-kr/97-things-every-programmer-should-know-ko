# 비즈니스 예외를 기술 예외와 구분하라

런타임에 문제가 발생하는 이유에는 기본적으로 두 가지가 있습니다: 애플리케이션 사용을 방해하는 기술적 문제와 애플리케이션 오용을 방지하는 비즈니스 논리입니다. LISP, Java, Smalltalk, C#과 같은 대부분의 현대 언어는 이러한 상황 모두를 신호하는 데 예외를 사용합니다. 그러나 두 상황은 매우 다르기 때문에 신중하게 구분해야 합니다. 같은 예외 계층을 사용하여 두 가지를 모두 나타내는 것은 혼란의 잠재적 원인이 될 수 있으며, 같은 예외 클래스를 사용하는 것은 더욱 문제를 야기합니다.

프로그램 오류로 인해 해결할 수 없는 기술적 문제가 발생할 수 있습니다. 예를 들어, 크기가 17인 배열에서 83번째 요소에 접근하려고 한다면, 프로그램은 분명히 잘못된 방향으로 진행되고 있으며, 어떤 예외가 발생해야 합니다. 더 미묘한 경우는 부적절한 인수로 라이브러리 코드를 호출하여 라이브러리 내부에서 동일한 상황이 발생하는 경우입니다.

스스로 야기한 이러한 상황을 해결하려고 시도하는 것은 실수입니다. 대신, 예외를 가장 높은 아키텍처 수준으로 전파하여 일반 예외 처리 메커니즘이 시스템을 안전한 상태로 유지하기 위해 할 수 있는 일을 하도록 해야 합니다. 예를 들어, 트랜잭션을 롤백하거나, 로그를 남기고 관리자에게 경고하거나, 사용자에게 정중하게 보고하는 등의 행동이 필요합니다.

이 상황의 변형은 "라이브러리 상황"에서 호출자가 메서드의 계약을 깨트렸을 때 발생합니다. 예를 들어, 전혀 이상한 인수를 전달하거나 종속 객체가 제대로 설정되어 있지 않는 경우입니다. 이는 크기가 17인 배열에서 83번째 요소에 접근하는 것과 동등합니다: 호출자(caller)는 확인했어야 하며, 그렇게 하지 않는 것은 클라이언트 측의 프로그래머 오류입니다. 적절한 대응은 기술 예외를 발생시키는 것입니다.

또 다른 기술적 상황은 실행 환경의 문제로 인해 프로그램이 계속 진행할 수 없는 경우입니다. 예를 들어, 반응하지 않는 데이터베이스가 있을 때입니다. 이 경우 인프라가 상황을 해결하기 위해 가능한 모든 노력을 했다고 가정해야 하며 - 연결을 수리하고 합리적인 횟수만큼 재시도를 했고 - 그리곤 실패한 것입니다. 원인이 다르더라도 호출 코드의 상황은 유사합니다: 이에 대해 할 수 있는 것은 거의 없습니다. 따라서, 우리는 이 상황을 예외를 통해 신호로 보내며, 이를 일반 예외 처리 메커니즘으로 전파합니다.

이와 대조적인 상황은 도메인 논리적인 이유로 호출을 완료할 수 없는 경우입니다. 이 경우 우리는 예외적인 상황에 직면했으며, 즉 비정상적이고 바람직하지 않지만 이상하거나 프로그래밍적으로 오류가 발생한 것은 아닙니다. 예를 들어, 잔액이 부족한 계좌에서 돈을 인출하려고 할 때입니다. 즉, 이러한 종류의 상황은 계약의 일부이며, 예외를 발생시키는 것은 모델의 일부인 *대체 반환 경로(alternative return path)*라는 것이며 클라이언트가 인식하고 처리할 준비가 되어 있어야 합니다. 이러한 상황에 대해서는 클라이언트가 상황을 스스로 처리할 수 있도록 특정 예외 또는 별도의 예외 계층을 만드는 것이 적절합니다.

기술 예외와 비즈니스 예외를 동일한 계층에서 혼합하면 구별이 흐릿해지고 호출자가 메서드 계약이 무엇인지, 호출하기 전에 보장해야 하는 조건이 무엇인지, 어떤 상황을 처리해야 하는지 혼란을 겪게 됩니다. 각 경우를 분리하면 명확성을 제공하고, 기술 예외가 일부 애플리케이션 프레임워크에 의해 처리될 확률이 높아지며, 비즈니스 도메인 예외는 실제로 클라이언트 코드에 의해 고려되고 처리됩니다.

[Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson) 씀.
