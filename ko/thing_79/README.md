# 코드 분석 도구를 활용하라

테스트의 가치는 소프트웨어 개발자들의 프로그래밍 여정 초기 단계부터 머릿속에 드럼처럼 박혀 있는 것입니다. 최근 몇 년 동안 단위 테스트, 테스트 주도 개발, 그리고 애자일 방법론의 부상으로 개발 사이클의 모든 단계에서 테스트를 최대한 활용하는 것에 대한 관심이 급증했습니다. 하지만 테스트는 코드 품질을 향상시키기 위해 사용할 수 있는 많은 도구 중 하나일 뿐입니다.

먼 옛날, C가 아직 새로운 현상이었을 때, CPU 시간과 모든 종류의 저장 공간은 매우 귀했습니다. 첫 번째 C 컴파일러들은 이것을 염두에 두고 일부 의미 분석을 제거함으로써 코드를 거치는 패스의 수를 줄였습니다. 이것은 컴파일러가 컴파일 시간에 감지될 수 있는 버그의 작은 부분집합만을 확인한다는 것을 의미했습니다. 이를 보상하기 위해 스티븐 존슨은 *lint*라는 도구를 작성했는데 — 이는 코드에서 보풀을 제거하는 것입니다 — 이것은 자매 C 컴파일러에서 제거되었던 정적 분석 중 일부를 구현했습니다. 하지만 정적 분석 도구들은 많은 수의 거짓 양성 경고들과 항상 따를 필요가 없는 문체적 관례에 대한 경고들을 준다는 평판을 얻었습니다.

언어, 컴파일러, 그리고 정적 분석 도구들의 현재 환경은 매우 다릅니다. 메모리와 CPU 시간은 이제 상대적으로 저렴하므로, 컴파일러들은 더 많은 오류를 확인할 여유가 있습니다. 거의 모든 언어가 스타일 가이드 위반, 일반적인 함정, 그리고 때로는 잠재적 null 포인터 역참조같이 잡기 어려울 수 있는 교묘한 오류들을 확인하는 도구를 적어도 하나는 자랑합니다. C를 위한 Splint나 Python을 위한 Pylint 같은 더 정교한 도구들은 구성 가능합니다. 즉, 구성 파일, 명령줄 스위치, 또는 IDE를 통해 도구가 내보내는 오류와 경고를 선택할 수 있습니다. Splint는 심지어 프로그램이 어떻게 작동하는지에 대한 더 나은 힌트를 주기 위해 주석으로 코드에 주석을 달게 해줍니다.

다른 모든 것이 실패하고, 컴파일러, IDE, 또는 lint 도구들에 의해 잡히지 않는 간단한 버그나 표준 위반을 찾고 있다면, 언제든지 자신만의 정적 검사기를 만들 수 있습니다. 이것은 들리는 것만큼 어렵지 않습니다. 대부분의 언어들, 특히 *동적*이라고 브랜드화된 것들은 추상 구문 트리와 컴파일러 도구들을 표준 라이브러리의 일부로 노출합니다. 당신이 사용하고 있는 언어의 개발팀이 사용하는 표준 라이브러리의 먼지 낀 구석들을 알아가는 것은 충분히 가치가 있는데, 이런 곳들에는 종종 정적 분석과 동적 테스트에 유용한 숨겨진 보석들이 포함되어 있기 때문입니다. 예를 들어, Python 표준 라이브러리에는 일부 컴파일된 코드나 코드 객체를 생성하는 데 사용된 바이트코드를 알려주는 디스어셈블러가 포함되어 있습니다. 이것은 python-dev 팀의 컴파일러 작성자들을 위한 모호한 도구처럼 들리지만, 실제로는 일상적인 상황에서 놀랍도록 유용합니다. 이 라이브러리가 디스어셈블할 수 있는 한 가지는 마지막 스택 추적으로, 마지막 잡히지 않은 예외를 던진 정확한 바이트코드 명령에 대한 피드백을 제공합니다.

그러므로 테스트가 품질 보증의 끝이 되도록 하지 마세요 — 분석 도구들을 활용하고 자신만의 것을 만드는 것을 두려워하지 마세요.

[Sarah Mount](http://programmer.97things.oreilly.com/wiki/index.php/Sarah_Mount)가 작성함.