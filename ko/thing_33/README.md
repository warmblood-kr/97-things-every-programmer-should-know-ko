# 부동소수점 숫자는 실수가 아니다

부동소수점 숫자는 수학적 의미에서 "실수(real numbers)"가 아닙니다. 비록 Pascal이나 Fortran 같은 일부 프로그래밍 언어에서 *real*이라고 불리지만 말입니다. 실수는 무한한 정밀도를 가지므로 연속적이고 손실이 없습니다. 부동소수점 숫자는 제한된 정밀도를 가지므로 유한하며, 범위 전체에 걸쳐 균등하게 분포되어 있지 않기 때문에 "잘못 동작하는" 정수와 비슷합니다.

예를 들어, 2147483647(가장 큰 부호 있는 32비트 정수)을 32비트 float 변수(x라고 하자)에 할당하고 출력해보세요. 2147483648이 보일 것입니다. 이제 `x - 64`를 출력해보세요. 여전히 2147483648입니다. 이제 `x - 65`를 출력하면 2147483520을 얻을 것입니다! 왜일까요? 그 범위에서 인접한 부동소수점 사이의 간격이 128이고, 부동소수점 연산은 가장 가까운 부동소수점 숫자로 반올림하기 때문입니다.

IEEE 부동소수점 숫자는 2진 과학적 표기법에 기반한 고정 정밀도 숫자입니다: 1.d<sub>1</sub>d<sub>2</sub>...d<sub>p-1</sub> × 2<sup>e</sup>, 여기서 *p*는 정밀도입니다(float는 24, double은 53). 연속된 두 숫자 사이의 간격은 2<sup>1-p+e</sup>이며, 이는 ε|x|로 안전하게 근사할 수 있습니다. 여기서 ε는 *머신 입실론(machine epsilon)*(2<sup>1-p</sup>)입니다.

부동소수점 숫자 근방의 간격을 아는 것은 고전적인 수치 실수를 피하는 데 도움이 될 수 있습니다. 예를 들어, 방정식의 근을 찾는 것과 같은 반복적 계산을 수행하고 있다면, 답 근방에서 숫자 시스템이 줄 수 있는 것보다 더 큰 정밀도를 요구하는 것은 의미가 없습니다. 요청하는 허용 오차가 그곳의 간격보다 작지 않도록 확인하세요. 그렇지 않으면 영원히 루프를 돌 것입니다.

부동소수점 숫자는 실수의 근사치이므로, 필연적으로 작은 오차가 존재합니다. *반올림 오차(roundoff)*라고 불리는 이 오차는 놀라운 결과를 가져올 수 있습니다. 예를 들어, 거의 같은 숫자들을 뺄 때, 가장 중요한 자릿수들이 서로 상쇄되므로 가장 덜 중요한 자릿수(반올림 오차가 있는 곳)가 부동소수점 결과에서 가장 중요한 위치로 승격되어, 본질적으로 관련된 추가 계산들을 오염시킵니다(*스미어링(smearing)*이라고 알려진 현상). 이런 *치명적 소거(catastrophic cancellation)*를 방지하기 위해 알고리즘을 자세히 살펴봐야 합니다. 예를 들어, 이차 공식으로 방정식 *x<sup>2</sup> - 100000x + 1 = 0*을 풀어보세요. 표현식 *-b + sqrt(b<sup>2</sup> - 4)*에서 피연산자들이 크기가 거의 같으므로, 대신 근 *r<sub>1</sub> = -b + sqrt(b<sup>2</sup> - 4)*를 계산하고, 그다음 *r<sub>2</sub> = 1/r<sub>1</sub>*을 얻을 수 있습니다. 어떤 이차 방정식 ax<sup>2</sup> + bx + c = 0에서도, 근들은 *r<sub>1</sub>r<sub>2</sub> = c/a*를 만족하기 때문입니다.

스미어링은 훨씬 더 미묘한 방식으로도 발생할 수 있습니다. 라이브러리가 공식 *1 + x + x<sup>2</sup>/2 + x<sup>3</sup>/3! + ...*로 *e<sup>x</sup>*를 순진하게 계산한다고 가정해보세요. 이것은 양수 *x*에서는 잘 작동하지만, *x*가 큰 음수일 때 무슨 일이 일어나는지 생각해보세요. 짝수 거듭제곱 항들은 큰 양수를 만들고, 홀수 거듭제곱 크기를 빼는 것은 결과에 영향을 주지도 않을 것입니다. 여기서 문제는 크고 양수인 항들의 반올림 오차가 진짜 답보다 훨씬 더 중요한 자릿수 위치에 있다는 것입니다. 답은 양의 무한대로 발산합니다! 여기서 해결책도 간단합니다: 음수 *x*에 대해서는 *e<sup>x</sup> = 1/e<sup>|x|</sup>*를 계산하세요.

금융 애플리케이션에 부동소수점 숫자를 사용하면 안 된다는 것은 말할 필요도 없습니다 — 그것은 Python이나 C# 같은 언어의 decimal 클래스가 하는 일입니다. 부동소수점 숫자는 효율적인 과학적 계산을 위한 것입니다. 하지만 정확성 없는 효율성은 가치가 없으므로, 반올림 오차의 원인을 기억하고 그에 따라 코딩하세요!

[Chuck Allison](http://programmer.97things.oreilly.com/wiki/index.php/Chuck_Allison)이 작성함.