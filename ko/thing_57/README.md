# 메시지 전달은 병렬 시스템에서 더 나은 확장성으로 이어진다

프로그래머들은 컴퓨팅 공부의 시작부터 동시성 — 그리고 특히 동시성의 특별한 부분집합인 병렬성 — 이 어렵다고, 가장 뛰어난 사람들만이 그것을 올바르게 할 수 있기를 바랄 수 있고, 심지어 그들도 틀린다고 배웁니다. 스레드, 세마포어, 모니터, 그리고 변수에 대한 동시 접근을 스레드 안전하게 만드는 것이 얼마나 어려운지에 대해 항상 큰 초점이 있습니다.

사실, 많은 어려운 문제들이 있고, 그것들은 해결하기 매우 어려울 수 있습니다. 하지만 문제의 근본은 무엇일까요? 공유 메모리입니다. 사람들이 계속해서 이야기하는 동시성의 문제들은 거의 모두 공유 가변 메모리의 사용과 관련이 있습니다: 경쟁 조건, 데드락, 라이브락 등. 답은 명백해 보입니다: 동시성을 포기하거나 공유 메모리를 피하는 것입니다!

동시성을 포기하는 것은 거의 확실히 선택사항이 아닙니다. 컴퓨터는 거의 분기마다 점점 더 많은 코어를 갖고 있으므로, 진정한 병렬성을 활용하는 것이 점점 더 중요해집니다. 애플리케이션 성능을 향상시키기 위해 계속 증가하는 프로세서 클록 속도에 더 이상 의존할 수 없습니다. 병렬성을 활용해야만 애플리케이션의 성능이 향상될 것입니다. 분명히, 성능을 향상시키지 않는 것도 선택사항이지만, 사용자들에게 받아들여질 가능성은 낮습니다.

그럼 공유 메모리를 피할 수 있을까요? 확실히 가능합니다.

프로그래밍 모델로 스레드와 공유 메모리를 사용하는 대신, 프로세스와 메시지 전달을 사용할 수 있습니다. 여기서 프로세스는 단순히 실행 코드가 있는 보호된 독립적 상태를 의미하며, 반드시 운영체제 프로세스일 필요는 없습니다. Erlang(그리고 그 이전의 occam) 같은 언어들은 프로세스가 동시 및 병렬 시스템을 프로그래밍하는 매우 성공적인 메커니즘임을 보여주었습니다. 그런 시스템들은 공유 메모리, 멀티스레드 시스템들이 갖는 모든 동기화 스트레스가 없습니다. 게다가 그런 시스템들의 엔지니어링의 일부로 적용될 수 있는 형식적 모델 — Communicating Sequential Processes (CSP) — 이 있습니다.

더 나아가서 컴퓨팅 방법으로 데이터플로우 시스템을 도입할 수 있습니다. 데이터플로우 시스템에서는 명시적으로 프로그래밍된 제어 흐름이 없습니다. 대신 데이터 경로로 연결된 연산자들의 방향 그래프가 설정되고 나서 데이터가 시스템에 공급됩니다. 평가는 시스템 내 데이터의 준비성에 의해 제어됩니다. 확실히 동기화 문제가 없습니다.

이 모든 것을 말했지만, C, C++, Java, Python, Groovy 같은 언어들이 시스템 개발의 주요 언어들이고 이 모든 것들이 프로그래머들에게 공유 메모리, 멀티스레드 시스템을 개발하기 위한 언어로 제시됩니다. 그럼 무엇을 할 수 있을까요? 답은 공유 가변 메모리의 모든 사용을 피하면서 프로세스 모델과 메시지 전달을 제공하는 라이브러리와 프레임워크를 사용하거나 — 존재하지 않는다면 — 만드는 것입니다.

전체적으로, 공유 메모리로 프로그래밍하지 않고 대신 메시지 전달을 사용하는 것이 이제 컴퓨터 하드웨어에 만연한 병렬성을 활용하는 시스템을 구현하는 가장 성공적인 방법일 가능성이 높습니다. 이상하게도, 프로세스가 동시성의 단위로서 스레드보다 앞서지만, 미래는 프로세스를 구현하기 위해 스레드를 사용하는 것에 있는 것 같습니다.

[Russel Winder](http://programmer.97things.oreilly.com/wiki/index.php/Russel_Winder)가 작성함.