# 상태로 생각하기

현실 세계의 사람들은 상태와 이상한 관계를 가지고 있습니다. 오늘 아침 나는 카페인을 코드로 변환하는 또 다른 하루를 준비하기 위해 지역 상점에 들렀습니다. 그것을 하는 내가 가장 좋아하는 방법은 라떼를 마시는 것인데, 우유를 찾을 수 없어서 점원에게 물어봤습니다.

"죄송하지만, 우리는 우유가 완전히, 엄청나게, 매우 떨어졌습니다."

프로그래머에게 그것은 이상한 진술입니다. 우유가 떨어졌거나 아니거나입니다. 우유가 떨어진 것에 대한 척도는 없습니다. 아마도 그녀는 일주일 동안 우유가 떨어져 있을 것이라고 말하려고 했을 것이지만, 결과는 같았습니다 — 나에게는 에스프레소 날이었습니다.

대부분의 현실 세계 상황에서, 사람들의 상태에 대한 느슨한 태도는 문제가 되지 않습니다. 불행히도 많은 프로그래머들도 상태에 대해 꽤 모호합니다 — 그리고 그것이 문제입니다.

신용카드만 받고 고객에게 송장을 보내지 않는 간단한 웹샵을 생각해보세요. 이 메서드를 포함하는 `Order` 클래스가 있습니다:

```
 public boolean isComplete() {
     return isPaid() && hasShipped();
 }
```

합리적이죠? 글쎄요, 표현식이 모든 곳에 복사해서 붙여넣기되는 대신 메서드로 잘 추출되었더라도, 그 표현식은 전혀 존재해서는 안 됩니다. 그것이 존재한다는 사실은 문제를 강조합니다. 왜일까요? 주문이 결제되기 전에는 배송될 수 없기 때문입니다. 따라서 `isPaid`가 true가 아니라면 `hasShipped`는 true가 될 수 없고, 이것은 표현식의 일부를 중복으로 만듭니다. 코드의 명확성을 위해 여전히 `isComplete`를 원할 수 있지만, 그러면 다음과 같이 보여야 합니다:

```
 public boolean isComplete() {
     return hasShipped();
 }
```

내 작업에서, 나는 누락된 검사와 중복된 검사를 항상 봅니다. 이 예시는 작지만, 취소와 환불을 추가하면 더 복잡해질 것이고 좋은 상태 처리의 필요성이 증가합니다. 이 경우, 주문은 세 가지 구별되는 상태 중 하나에만 있을 수 있습니다:

- *진행 중:* 항목을 추가하거나 제거할 수 있습니다. 배송할 수 없습니다.
- *결제됨:* 항목을 추가하거나 제거할 수 없습니다. 배송될 수 있습니다.
- *배송됨:* 완료. 더 이상의 변경은 받아들여지지 않습니다.

이런 상태들은 중요하고 당신은 작업을 하기 전에 예상되는 상태에 있는지 확인해야 하고, 당신이 있는 곳에서 합법적인 상태로만 이동해야 합니다. 간단히 말해서, 당신은 올바른 장소에서 객체들을 신중하게 보호해야 합니다.

하지만 어떻게 상태로 생각하기를 시작할까요? 표현식을 의미 있는 메서드로 추출하는 것은 매우 좋은 시작이지만, 그것은 단지 시작일 뿐입니다. 기초는 상태 머신을 이해하는 것입니다. CS 수업에서 나쁜 기억을 가지고 있을지도 모르지만, 그것들을 뒤로 남겨두세요. 상태 머신은 특별히 어렵지 않습니다. 그것들을 이해하기 쉽고 이야기하기 쉽게 만들기 위해 시각화하세요. 유효하고 무효한 상태와 전환을 밝혀내고 그것들을 올바르게 유지하기 위해 코드를 테스트 주도하세요. 상태 패턴을 공부하세요. 편안해지면, 계약에 의한 설계를 읽어보세요. 그것은 들어오는 데이터와 각 공개 메서드의 진입과 종료에서 객체 자체를 검증함으로써 유효한 상태를 보장하는 데 도움이 됩니다.

상태가 올바르지 않다면, 버그가 있고 중단하지 않으면 데이터를 망칠 위험이 있습니다. 상태 검사들이 소음이라고 발견하면, 그것들을 숨기기 위해 도구, 코드 생성, 위빙, 또는 애스펙트를 사용하는 방법을 배우세요. 어떤 접근법을 선택하든, 상태로 생각하는 것은 당신의 코드를 더 단순하고 더 견고하게 만들 것입니다.

[Niclas Nilsson](http://programmer.97things.oreilly.com/wiki/index.php/Niclas_Nilsson)이 작성함.