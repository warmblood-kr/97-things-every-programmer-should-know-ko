# 도메인의 언어로 코딩하라

두 개의 코드베이스를 상상해보세요. 하나에서 당신은 다음과 같은 코드를 발견합니다:

```
if (portfolioIdsByTraderId.get(trader.getId())
  .containsKey(portfolio.getId())) {...}
```

머리를 긁적이며, 이 코드가 무엇을 위한 것인지 궁금해합니다. trader 객체에서 ID를 가져와서, 그것을 사용해 맵-of-맵으로 보이는 것에서 맵을 가져오고, 그 다음 portfolio 객체의 다른 ID가 내부 맵에 존재하는지 보는 것 같습니다. 더 머리를 긁적입니다. portfolioIdsByTraderId의 선언을 찾아보고 다음을 발견합니다:

```
Map<int, Map<int, int>> portfolioIdsByTraderId;
```

점차 트레이더가 특정 포트폴리오에 접근할 수 있는지와 관련된 것일 수도 있다는 것을 깨닫게 됩니다. 그리고 물론 동일한 검색 조각 — 또는 더 가능성 높게는 비슷하지만-미묘하게-다른 코드 조각 — 을 트레이더가 특정 포트폴리오에 접근할 수 있는지 신경 쓰는 곳마다 발견하게 될 것입니다.

다른 코드베이스에서는 다음과 같은 것을 발견합니다:

```
if (trader.canView(portfolio)) {...}
```

머리를 긁적일 필요가 없습니다. 트레이더가 어떻게 아는지 알 필요가 없습니다. 아마도 어딘가 내부에 이런 맵-of-맵 중 하나가 숨어있을 것입니다. 하지만 그것은 트레이더의 일이지, 당신의 일이 아닙니다.

이제 이 두 코드베이스 중 어디서 작업하고 싶으시겠습니까?

옛날에는 매우 기본적인 데이터 구조만 있었습니다: 비트와 바이트 그리고 문자들(실제로는 바이트이지만 우리는 그것들이 글자와 구두점이라고 가정했습니다). 십진수는 조금 까다로웠는데 우리의 십진법 숫자가 이진법에서는 잘 작동하지 않았기 때문에, 여러 크기의 부동소수점 타입이 있었습니다. 그 다음에는 배열과 문자열(실제로는 서로 다른 배열들)이 나왔습니다. 그리고 스택과 큐와 해시와 연결 리스트와 스킵 리스트 그리고 *현실 세계에는 존재하지 않는* 많은 다른 흥미로운 데이터 구조들이 있었습니다. "컴퓨터 과학"은 현실 세계를 우리의 제한적인 데이터 구조에 매핑하는 데 많은 노력을 들이는 것이었습니다. 진짜 구루들은 심지어 그들이 어떻게 그것을 했는지 기억할 수도 있었습니다.

그런 다음 사용자 정의 타입을 얻었습니다! 좋아요, 이것은 새로운 소식은 아니지만, 게임을 어느 정도 바꿔놓습니다. 도메인에 트레이더와 포트폴리오 같은 개념이 포함되어 있다면, Trader와 Portfolio라고 불리는 타입으로 그것들을 모델링할 수 있습니다. 하지만 이보다 더 중요한 것은, 도메인 용어를 사용해서 *그들 사이의 관계*도 모델링할 수 있다는 것입니다.

도메인 용어를 사용해서 코딩하지 않는다면, 여기 있는 *이* int는 트레이더를 식별하는 방법을 의미하는 반면, 저기 있는 *저* int는 포트폴리오를 식별하는 방법을 의미한다는 암묵적인(읽기: 비밀스러운) 이해를 만들어내고 있는 것입니다. (그것들을 섞지 않는 것이 최선입니다!) 그리고 비즈니스 개념("일부 트레이더는 일부 포트폴리오를 볼 수 없습니다 — 불법입니다")을 알고리즘 조각, 예를 들어 키의 맵에서의 존재 관계로 표현한다면, 감사와 컴플라이언스 담당자들에게 호의를 베푸는 것이 아닙니다.

다음에 올 프로그래머는 비밀을 알지 못할 수도 있으니, 왜 명시적으로 만들지 않을까요? 키를 다른 키에 대한 검색으로 사용해서 존재 검사를 수행하는 것은 그리 명백하지 않습니다. 누군가가 그곳이 이해충돌을 방지하는 비즈니스 규칙이 구현된 곳이라고 어떻게 직감할 수 있겠습니까?

코드에서 도메인 개념을 명시적으로 만드는 것은 다른 프로그래머들이 알고리즘을 도메인에 대해 이해하는 것에 끼워맞추려고 시도하는 것보다 훨씬 쉽게 코드의 *의도*를 파악할 수 있다는 것을 의미합니다. 또한 도메인 모델이 진화할 때 — 도메인에 대한 이해가 깊어지면서 진화할 것입니다 — 코드를 진화시킬 수 있는 좋은 위치에 있다는 것을 의미합니다. 좋은 캡슐화와 결합되면, 규칙이 한 곳에만 존재할 가능성이 높고, 의존적인 코드가 전혀 알지 못하는 상태에서 그것을 변경할 수 있습니다.

몇 달 후 코드를 작업하러 올 프로그래머가 당신에게 감사할 것입니다. 몇 달 후 올 프로그래머는 당신일 수도 있습니다.

[Dan North](http://programmer.97things.oreilly.com/wiki/index.php/Dan_North)가 작성함.