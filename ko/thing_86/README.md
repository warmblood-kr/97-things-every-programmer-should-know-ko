# 두 개의 잘못이 옳은 것을 만들 수 있다 (그리고 고치기 어렵다)

코드는 결코 거짓말을 하지 않지만, 자기 자신과 모순될 수는 있습니다. 일부 모순들은 "그것이 어떻게 가능하게 작동할 수 있을까?" 순간들로 이어집니다.

한 [인터뷰](http://www.netjeff.com/humor/item.cgi?file=ApolloComputer)에서, 아폴로 11호 달 착륙선 소프트웨어의 주 설계자인 Allan Klumpp는 엔진을 제어하는 소프트웨어가 착륙선을 불안정하게 만들었어야 할 버그를 포함하고 있었다고 밝혔습니다. 하지만 다른 버그가 첫 번째를 보상했고, 그 소프트웨어는 두 버그 중 어느 것도 발견되거나 고쳐지기 전에 아폴로 11호와 12호 달 착륙 모두에 사용되었습니다.

완료 상태를 반환하는 함수를 생각해보세요. 그것이 true를 반환해야 할 때 false를 반환한다고 상상해보세요. 이제 호출하는 함수가 반환 값을 확인하는 것을 소홀히 한다고 상상해보세요. 어느 날 누군가가 누락된 검사를 발견하고 그것을 삽입할 때까지 모든 것이 잘 작동합니다.

또는 상태를 XML 문서로 저장하는 애플리케이션을 생각해보세요. 노드 중 하나가 문서에서 말하는 대로 `TimeToDie` 대신 `TimeToLive`로 잘못 작성되었다고 상상해보세요. 작성자 코드와 읽기 코드 모두가 같은 오류를 포함하고 있는 동안에는 모든 것이 괜찮게 보입니다. 하지만 하나를 고치거나 같은 문서를 읽는 새로운 애플리케이션을 추가하면, 대칭성이 깨지고 코드도 깨집니다.

코드의 두 결함이 하나의 가시적 장애를 만들 때, 장애를 고치는 체계적 접근법 자체가 무너질 수 있습니다. 개발자는 버그 리포트를 받고, 결함을 찾고, 고치고, 다시 테스트합니다. 하지만 두 번째 결함이 작동하고 있기 때문에 보고된 장애가 여전히 발생합니다. 그래서 첫 번째 수정이 제거되고, 두 번째 기본 결함이 발견될 때까지 코드가 검사되고, 그것에 대한 수정이 적용됩니다. 하지만 첫 번째 결함이 돌아왔고, 보고된 장애가 여전히 보이므로, 두 번째 수정이 롤백됩니다. 과정이 반복되지만 이제 개발자는 두 가지 가능한 수정을 기각했고 결코 작동하지 않을 세 번째를 만들려고 합니다.

하나의 가시적 장애로 나타나는 두 코드 결함 사이의 상호작용은 문제를 고치기 어렵게 만들 뿐만 아니라 개발자들을 막다른 골목으로 이끌어, 그들이 초기에 올바른 답을 시도했다는 것을 발견하게 합니다.

이것은 코드에서만 일어나지 않습니다: 문제는 작성된 요구사항 문서에도 존재합니다. 그리고 그것은 바이러스처럼 한 곳에서 다른 곳으로 퍼질 수 있습니다. 코드의 오류가 작성된 설명의 오류를 보상합니다.

그것은 사람들에게도 퍼질 수 있습니다: 사용자들은 애플리케이션이 왼쪽이라고 말할 때 오른쪽을 의미한다는 것을 배우므로, 그에 따라 그들의 행동을 조정합니다. 그들은 심지어 그것을 새로운 사용자들에게도 전달합니다: "그 애플리케이션이 왼쪽 버튼을 클릭하라고 말할 때 실제로는 오른쪽 버튼을 의미한다는 것을 기억하세요." 버그를 고치면 갑자기 사용자들이 재교육을 받아야 합니다.

단일 잘못들은 발견하기 쉽고 고치기 쉬울 수 있습니다. 여러 원인을 가지고, 여러 변경을 필요로 하는 문제들이 해결하기 더 어렵습니다. 부분적으로는 쉬운 문제들이 너무 쉽게 고쳐져서 사람들이 상대적으로 빠르게 그것들을 고치고 더 어려운 문제들을 나중으로 미루는 경향이 있기 때문입니다.

공감적 결함들에서 발생하는 장애들을 어떻게 다룰지에 대한 간단한 조언을 주기는 어렵습니다. 가능성에 대한 인식, 명확한 머리, 그리고 모든 가능성을 고려하려는 의지가 필요합니다.

[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)가 작성함.