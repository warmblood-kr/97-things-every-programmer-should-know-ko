# 프로세스 간 통신이 애플리케이션 응답 시간에 미치는 영향

응답 시간은 소프트웨어 사용성에 중요합니다. 어떤 소프트웨어 시스템이 응답하기를 기다리는 것만큼 좌절스러운 것은 거의 없으며, 특히 소프트웨어와의 상호작용이 자극과 응답의 반복적인 사이클을 포함할 때 그렇습니다. 우리는 소프트웨어가 우리의 시간을 낭비하고 생산성에 영향을 미치고 있다고 느낍니다. 하지만 느린 응답 시간의 원인은 특히 현대 애플리케이션에서 잘 알려져 있지 않습니다. 많은 성능 관리 문헌들이 여전히 데이터 구조와 알고리즘에 초점을 맞추고 있는데, 이는 어떤 경우에는 차이를 만들 수 있지만 현대 다중 계층 엔터프라이즈 애플리케이션에서 성능을 지배할 가능성은 훨씬 낮습니다.

그런 애플리케이션에서 성능이 문제일 때, 제 경험으로는 데이터 구조와 알고리즘을 검토하는 것이 개선을 찾기 위한 올바른 장소가 아닙니다. 응답 시간은 자극에 대한 응답으로 수행되는 원격 프로세스 간 통신(IPC)의 수에 가장 강하게 의존합니다. 다른 로컬 병목 현상이 있을 수 있지만, 원격 프로세스 간 통신의 수가 보통 지배적입니다. 각 원격 프로세스 간 통신은 전체 응답 시간에 무시할 수 없는 지연을 기여하며, 이런 개별 기여들이 누적되고, 특히 순차적으로 발생할 때 그렇습니다.

대표적인 예는 객체-관계 매핑을 사용하는 애플리케이션에서의 *리플 로딩*입니다. 리플 로딩은 객체 그래프를 구축하는 데 필요한 데이터를 선택하기 위한 많은 데이터베이스 호출의 순차적 실행을 설명합니다(Martin Fowler의 *Patterns of Enterprise Application Architecture*에서 [Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html) 참조). 데이터베이스 클라이언트가 웹 페이지를 렌더링하는 중간 계층 애플리케이션 서버일 때, 이런 데이터베이스 호출들은 보통 단일 스레드에서 순차적으로 실행됩니다. 그들의 개별 지연들이 누적되어 전체 응답 시간에 기여합니다. 각 데이터베이스 호출이 단지 10ms만 걸리더라도, 1000번의 호출이 필요한 페이지(흔하지 않은 일이 아님)는 최소 10초의 응답 시간을 보일 것입니다. 다른 예로는 웹 서비스 호출, 웹 브라우저로부터의 HTTP 요청, 분산 객체 호출, 요청-응답 메시징, 그리고 커스텀 네트워크 프로토콜을 통한 데이터 그리드 상호작용이 있습니다. 자극에 응답하는 데 필요한 원격 IPC가 많을수록, 응답 시간은 더 길어질 것입니다.

자극당 원격 프로세스 간 통신의 수를 줄이기 위한 몇 가지 상대적으로 명백하고 잘 알려진 전략들이 있습니다. 한 전략은 절약의 원칙을 적용하여, 프로세스 간 인터페이스를 최적화해서 당면한 목적에 정확히 맞는 데이터가 최소한의 상호작용으로 교환되도록 하는 것입니다. 다른 전략은 가능한 곳에서 프로세스 간 통신을 병렬화하여, 전체 응답 시간이 주로 가장 긴 지연을 가진 IPC에 의해 결정되도록 하는 것입니다. 세 번째 전략은 이전 IPC의 결과를 캐시하여, 로컬 캐시를 히트함으로써 미래의 IPC를 피할 수 있도록 하는 것입니다.

애플리케이션을 설계할 때, 각 자극에 대한 응답으로 일어나는 프로세스 간 통신의 수를 염두에 두세요. 성능이 좋지 않은 애플리케이션을 분석할 때, 저는 종종 수천 대 일의 IPC 대 자극 비율을 발견했습니다. 캐싱이나 병렬화 또는 다른 기법으로 이 비율을 줄이는 것은 데이터 구조 선택을 바꾸거나 정렬 알고리즘을 조정하는 것보다 훨씬 더 효과적일 것입니다.

[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)이 작성함.