# 링커는 마법의 프로그램이 아니다

우울할 정도로 자주 (이 글을 쓰기 직전에도 제게 일어났습니다), 많은 프로그래머들이 컴파일된 언어에서 소스 코드로부터 정적으로 링크된 실행 파일을 만드는 과정에 대해 갖고 있는 관점은 다음과 같습니다:

1. 소스 코드 편집
2. 소스 코드를 오브젝트 파일로 컴파일
3. 마법 같은 일이 일어남
4. 실행 파일 실행

3단계는 물론 링킹 단계입니다. 제가 왜 이런 터무니없는 말을 할까요? 저는 수십 년 동안 기술 지원을 해왔고, 다음과 같은 질문들을 계속해서 받습니다:

- 링커가 def가 두 번 이상 정의되었다고 합니다.
- 링커가 abc가 미해결 심볼이라고 합니다.
- 제 실행 파일이 왜 이렇게 큰가요?

그 다음에는 "이제 어떻게 해야 하나요?"가 이어지는데, 보통 "~인 것 같다"와 "어떻게든"이라는 구문이 섞여 있고, 완전히 당황한 분위기가 감돕니다. 링킹 과정이 마법적인 과정으로 여겨지고 있다는 것을 나타내는 것이 바로 "~인 것 같다"와 "어떻게든"이며, 아마도 마법사와 흑마법사들만 이해할 수 있다고 추정됩니다. 컴파일 과정은 이런 종류의 구문을 이끌어내지 않는데, 이는 프로그래머들이 일반적으로 컴파일러가 어떻게 작동하는지, 또는 적어도 무엇을 하는지 이해한다는 것을 함의합니다.

링커는 매우 바보스럽고, 평범하고, 직관적인 프로그램입니다. 링커가 하는 일은 오브젝트 파일들의 코드와 데이터 섹션을 연결하고, 심볼 참조를 그들의 정의와 연결하고, 라이브러리에서 미해결 심볼을 끌어내고, 실행 파일을 작성하는 것뿐입니다. 그게 전부입니다. 주문도 없고! 마법도 없습니다! 링커를 작성할 때의 지루함은 보통 터무니없이 과도하게 복잡한 파일 형식을 디코딩하고 생성하는 것에 관한 것이지만, 그것이 링커의 본질적인 성격을 바꾸지는 않습니다.

그럼 링커가 def가 두 번 이상 정의되었다고 말한다고 합시다. C, C++, D 같은 많은 프로그래밍 언어들은 선언과 정의를 모두 갖고 있습니다. 선언은 보통 헤더 파일로 들어가며, 다음과 같습니다:

```
extern int iii;
```

이것은 심볼 `iii`에 대한 외부 참조를 생성합니다. 반면에 정의는 실제로 심볼을 위한 저장소를 마련하고, 보통 구현 파일에 나타나며, 다음과 같이 생겼습니다:

```
int iii = 3;
```

각 심볼에 대해 몇 개의 정의가 있을 수 있을까요? 영화 *하이랜더*에서처럼, 오직 하나만 있을 수 있습니다. 그럼 iii의 정의가 두 개 이상의 구현 파일에 나타난다면 어떻게 될까요?

```
// File a.c
int iii = 3;
```

```
// File b.c
double iii(int x) { return 3.7; }
```

링커는 `iii`가 중복 정의되었다고 불평할 것입니다.

오직 하나만 있을 수 있을 뿐만 아니라, 하나는 있어야 합니다. iii가 선언으로만 나타나고 정의는 전혀 없다면, 링커는 iii가 미해결 심볼이라고 불평할 것입니다.

실행 파일이 왜 그 크기인지 알아보려면, 링커가 선택적으로 생성하는 맵 파일을 살펴보세요. 맵 파일은 실행 파일의 모든 심볼들과 그들의 주소 목록에 불과합니다. 이것은 라이브러리에서 어떤 모듈들이 링크되었는지와 각 모듈의 크기를 알려줍니다. 이제 비대함이 어디서 오는지 볼 수 있습니다. 종종 왜 링크되었는지 전혀 모르겠는 라이브러리 모듈들이 있을 것입니다. 그것을 알아내려면, 의심스러운 모듈을 라이브러리에서 일시적으로 제거하고 다시 링크하세요. 그러면 생성되는 미정의 심볼 에러가 누가 그 모듈을 참조하고 있는지 나타낼 것입니다.

특정 링커 메시지를 받는 이유가 항상 즉시 명백한 것은 아니지만, 링커에 대해 마법적인 것은 없습니다. 메커니즘은 직관적입니다; 각각의 경우에 해결해야 하는 것은 세부사항입니다.

[Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)가 작성함.