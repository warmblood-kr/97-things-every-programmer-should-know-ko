# 상태만이 아닌 행동을 캡슐화하라

시스템 이론에서 격리(containment)는 크고 복잡한 시스템 구조를 다룰 때 가장 유용한 구조체 중 하나입니다. 소프트웨어 업계에서 격리 또는 캡슐화의 가치는 잘 이해되고 있습니다. 격리는 서브루틴과 함수, 모듈과 패키지, 클래스 등과 같은 프로그래밍 언어 구조체에 의해 지원됩니다.

모듈과 패키지는 캡슐화의 더 큰 규모의 요구사항을 해결하는 반면, 클래스, 서브루틴, 함수는 이 문제의 더 세밀한 측면을 다룹니다. 수년간 저는 클래스가 개발자들이 올바르게 이해하기 가장 어려운 캡슐화 구조체 중 하나인 것 같다는 것을 발견했습니다. 단일 3000줄 메인 메서드를 가진 클래스나, 기본 속성들에 대한 *set*과 *get* 메서드만 가진 클래스를 찾는 것은 흔한 일입니다. 이런 예시들은 관련된 개발자들이 객체지향적 사고를 완전히 이해하지 못했음을 보여주며, 모델링 구조체로서 객체의 힘을 활용하는 데 실패했습니다. POJO(Plain Old Java Object)와 POCO(Plain Old C# Object 또는 Plain Old CLR Object) 용어에 익숙한 개발자들에게, 이것이 모델링 패러다임으로서 OO의 기본으로 돌아가려는 의도였습니다 — 객체는 평범하고 단순하지만, 멍청하지는 않습니다.

객체는 상태와 행동을 모두 캡슐화하며, 행동은 실제 상태에 의해 정의됩니다. 문(door) 객체를 생각해보세요. 이것은 네 가지 상태를 가집니다: 닫힘, 열림, 닫히는 중, 열리는 중. 두 가지 동작을 제공합니다: 열기와 닫기. 상태에 따라 열기와 닫기 동작은 다르게 작동할 것입니다. 객체의 이런 고유한 속성은 설계 과정을 개념적으로 간단하게 만듭니다. 이는 두 가지 간단한 작업으로 귀결됩니다: 객체 간 상호작용 프로토콜을 포함하여 서로 다른 객체들에 대한 책임의 할당과 위임.

이것이 실제로 어떻게 작동하는지는 예시로 가장 잘 설명됩니다. Customer, Order, Item이라는 세 개의 클래스가 있다고 해봅시다. Customer 객체는 신용 한도와 신용 검증 규칙의 자연스러운 자리표시자입니다. Order 객체는 연관된 Customer를 알고 있으며, 그것의 addItem 동작은 `customer.validateCredit(item.price())`를 호출하여 실제 신용 확인을 위임합니다. 메서드의 후조건이 실패하면, 예외가 던져지고 구매가 중단될 수 있습니다.

경험이 적은 객체지향 개발자들은 모든 비즈니스 규칙을 `OrderManager`나 `OrderService`라고 자주 불리는 객체에 감쌀 수도 있습니다. 이런 설계에서 `Order`, `Customer`, `Item`은 레코드 타입에 조금 더한 것 정도로 취급됩니다. 모든 로직이 클래스에서 빼내져서 많은 내부 *if-then-else* 구조체를 가진 하나의 크고 절차적인 메서드에 묶입니다. 이런 메서드들은 쉽게 망가지고 유지보수가 거의 불가능합니다. 이유는? 캡슐화가 깨졌기 때문입니다.

그러므로 결국, 캡슐화를 깨뜨리지 말고, 그것을 유지하기 위해 당신의 프로그래밍 언어의 힘을 사용하세요.

[Einar Landre](http://programmer.97things.oreilly.com/wiki/index.php/Einar_Landre)가 작성함.