# 성능으로 가는 길은 더러운 코드 폭탄으로 뒤덮여 있다

종종 시스템의 성능 튜닝을 하려면 코드를 변경해야 합니다. 코드를 변경해야 할 때, 지나치게 복잡하거나 높은 결합도를 가진 모든 청크는 노력을 탈선시키기 위해 대기하고 있는 더러운 코드 폭탄입니다. 더러운 코드의 첫 번째 희생자는 당신의 일정이 될 것입니다. 앞으로 나아갈 길이 매끄럽다면 언제쯤 끝낼지 예측하기 쉬울 것입니다. 더러운 코드와의 예상치 못한 만남은 정상적인 예측을 하는 것을 매우 어렵게 만들 것입니다.

실행 핫스팟을 발견하는 경우를 생각해보세요. 일반적인 행동 과정은 기본 알고리즘의 강도를 줄이는 것입니다. 당신이 매니저의 추정 요청에 3-4시간이라는 답변으로 응답한다고 해봅시다. 수정을 적용하면서 당신은 종속된 부분을 망가뜨렸다는 것을 빠르게 깨닫습니다. 밀접하게 관련된 것들은 종종 필연적으로 결합되어 있기 때문에, 이런 고장은 대부분 예상되고 고려됩니다. 하지만 그 의존성을 고치는 것이 다른 종속된 부분들을 망가뜨리는 결과를 가져온다면 어떻게 될까요? 게다가 의존성이 원점에서 멀어질수록, 당신이 그것을 그런 것으로 인식하고 추정에서 고려할 가능성이 낮아집니다. 갑자기 당신의 3-4시간 추정이 쉽게 3-4주로 부풀어질 수 있습니다. 종종 이런 예상치 못한 일정 팽창은 한 번에 1-2일씩 일어납니다. "빠른" 리팩토링이 결국 완료되는 데 몇 달이 걸리는 것을 보는 것은 드문 일이 아닙니다. 이런 경우들에서, 책임 있는 팀의 신뢰성과 정치적 자본에 대한 손상은 심각한 것에서 치명적인 것까지 범위에 있을 것입니다. 우리에게 이 위험을 식별하고 측정하는 데 도움이 되는 도구가 있다면 좋을 텐데요.

사실, 우리는 코드의 결합도와 복잡성의 정도와 깊이를 측정하고 제어하는 많은 방법을 가지고 있습니다. 소프트웨어 메트릭은 우리 코드에서 특정 기능의 발생을 세는 데 사용될 수 있습니다. 이런 개수의 값들은 코드 품질과 상관관계가 있습니다. 결합도를 측정하는 여러 메트릭 중 두 가지는 팬인(fan-in)과 팬아웃(fan-out)입니다. 클래스에 대한 팬아웃을 생각해보세요: 이것은 관심 있는 클래스에서 직접 또는 간접적으로 참조되는 클래스의 수로 정의됩니다. 이것을 당신의 클래스가 컴파일되기 전에 컴파일되어야 하는 모든 클래스의 개수로 생각할 수 있습니다. 반면에 팬인은 관심 클래스에 의존하는 모든 클래스의 개수입니다. 팬아웃과 팬인을 알면 *I = f<sub>o</sub> / (f<sub>i</sub> + f<sub>o</sub>)*를 사용하여 불안정성 팩터를 계산할 수 있습니다. *I*가 0에 가까워질수록 패키지는 더 안정해집니다. *I*가 1에 가까워질수록 패키지는 불안정해집니다. 안정한 패키지들은 리코딩을 위한 저위험 대상인 반면 불안정한 패키지들은 더러운 코드 폭탄으로 가득 찰 가능성이 더 높습니다. 리팩토링의 목표는 *I*를 0에 더 가깝게 이동시키는 것입니다.

메트릭을 사용할 때는 그것들이 단지 경험 법칙이라는 것을 기억해야 합니다. 순전히 수학적으로 우리는 f<sub>o</sub>를 변경하지 않고 *f<sub>i</sub>*를 증가시키는 것이 *I*를 0에 더 가깝게 이동시킬 것이라는 것을 볼 수 있습니다. 하지만 매우 큰 팬인 값에는 단점이 있는데, 이런 클래스들은 종속된 것들을 망가뜨리지 않고 변경하기가 더 어려울 것입니다. 또한 팬아웃을 다루지 않으면 실제로 위험을 줄이지 않는 것이므로 어떤 균형이 적용되어야 합니다.

소프트웨어 메트릭의 한 가지 단점은 메트릭 도구들이 생산하는 엄청난 숫자 배열이 초보자에게 위협적일 수 있다는 것입니다. 그렇긴 하지만, 소프트웨어 메트릭은 깨끗한 코드를 위한 우리의 싸움에서 강력한 도구가 될 수 있습니다. 그것들은 더러운 코드 폭탄들이 성능 튜닝 연습에 심각한 위험이 되기 전에 식별하고 제거하는 데 도움이 될 수 있습니다.

[Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)이 작성함.