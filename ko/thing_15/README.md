# 추론하며 코딩하기[^1]

소프트웨어의 정확성(correctness)에 대해 수작업으로 추론하려고 하면, 그 코드보다 긴 공식 증명(formal proof)이 나오게 되며, 이는 그 코드보다 오류를 가지고 있을 가능성이 더 큽니다. 자동화 도구가 바람직하지만, 항상 가능한 것은 아닙니다. 다음에서는 중간적 접근 방식(middle path)을 설명합니다: 정확성에 대해 반정형적(semi-formally)으로 추론하기(reasoning).

기본 접근(underlying approach)은 고려 대상인 모든 코드를 더 짧은 섹션들로 나누는 것입니다. 각 섹션은 단일 행, 예를 들어 함수 호출부터, 10행 미만의 블록들에 이르기까지 - 그리고 그 정확성에 대해 논의(arguing))합니다. 주장(arguments)은 동료 프로그래머인 악마의 대변인(devil's advocate)을 설득할 수 있을 만큼 강력해야 합니다.

각 섹션은 프로그램의 각 끝점(endpoint)에서 *프로그램의 상태(state of the program)* (즉, 프로그램 카운터와 모든 "살아 있는" 객체의 값)가 쉽게 설명할 수 있는 속성을 만족하도록 선택해야 하며, 이 섹션의 기능(상태 변환)은 단일 작업으로 설명하기 쉬워야 합니다. 이러한 조건들은 논리를 단순화하는 데 도움이 됩니다. 이러한 끝점 속성은 함수의 *사전 조건(precondition)*, *사후 조건(postcondition)*, 반복문 및 클래스(그들의 인스턴스에 대한)의 *불변식(invariant)*와 같은 개념을 일반화합니다. 섹션들이 최대한 서로 독립적이도록 만들기 위해 노력하는(striving) 것은 추론을 단순화시켜 주며, 이러한 섹션이 변경될 때 필수적(indispensable)입니다.

잘 알려진, 그러나 아마도 덜 지켜지는 '좋은' 코딩 관행들은 논리를 더 쉽게 만들어줍니다. 따라서 코드를 논리적으로 다룰 생각만 해도 이미 더 나은 스타일과 구조를 생각하게 됩니다. 놀랍지 않게도, 이러한 대부분의 관행은 정적 코드 분석기를 통해 확인할 수 있습니다:

- 원거리 섹션의 상호 의존성을 극대화하는 `goto` 문 사용을 피하세요.
- 수정 가능한 전역 변수를 피하세요. 이는 이러한 변수를 사용하는 모든 섹션이 서로 의존하게 만듭니다.
- 각 변수의 범위는 가능한 한 작아야 합니다. 예를 들어, 지역 객체는 처음 사용하기 직전에 선언할 수 있습니다.
- 관련이 있을 때는 객체를 *불변(immutable)*으로 만드세요.
- 수평 및 수직으로 여백을 사용하여 코드를 읽기 쉽게 만드세요. 예를 들어, 관련 구조를 정렬하고 두 섹션을 구분하기 위해 빈 줄을 사용하는 것이 좋습니다.
- 객체, 타입, 함수 등에 대해 설명적이면서도 상대적으로 짧은 이름을 선택하여 코드를 자체 문서화하십시오.
- 중첩된 섹션이 필요하다면, 함수를 만드세요.
- 함수는 짧고 단일 작업에 집중해야 합니다. 옛날의 *24행 제한*은 여전히 유효합니다. 화면 크기와 해상도는 변화했지만, 1960년대 이후 인간 인지에 변화는 없었습니다.
- 함수는 매개변수를 적게 가져야 합니다(4개가 좋은 상한선입니다). 이것은 함수에 전달되는 데이터의 제한을 두지 않습니다: 관련 매개변수를 단일 객체로 그룹화하는 것은 *객체 불변성(Object Invariants)*에 도움이 되며, 그 일관성과 응집력과 같은 논리를 절약할 수 있습니다.
- 보다 일반적으로, 블록에서 라이브러리에 이르기까지 코드의 각 단위는 *좁은 인터페이스(narrow interface)*를 가져야 합니다. 통신이 감소하면 요구되는 논리가 줄어듭니다. 이는 내부 상태를 반환하는 *getter*가 불리하다는 것을 의미합니다 — 작업을 수행하기 위해 객체에 정보를 요청하지 마세요. 대신, 이미 가진 정보를 가지고 작업을 수행하도록 객체에 요청하세요. 즉, *캡슐화(encapsulation)*는 *좁은 인터페이스*에 관한 모든 것입니다.
- 클래스의 *불변성(invariants)*을 유지하기 위해서는 *setter*의 사용을 권장하지 않아야 합니다. *setter*는 객체 상태를 규제하는 불변성을 깨뜨릴 수있습니다.

정확성에 대한 논리적 접근 외에도, 코드를 논의하는 것은 코드에 대한 이해를 제공합니다. 여러분이 얻은 통찰을 모든 사람에게 알리세요.

[Yechiel Kimchi](http://programmer.97things.oreilly.com/wiki/index.php/Yechiel_Kimchi) 씀.

[^1]: Coding with Reason.
