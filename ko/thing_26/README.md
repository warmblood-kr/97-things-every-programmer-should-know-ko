# 그 에러를 무시하지 마라!

> *어느 날 저녁 바에서 친구들을 만나기 위해 길을 걷고 있었다. 한동안 맥주를 함께 마시지 못했고 다시 보게 되기를 기대하고 있었다. 서둘러서 어디로 가는지 보지 않고 있었다. 연석 끝에 걸려 넘어져서 얼굴부터 바닥에 떨어졌다. 글쎄, 주의를 기울이지 않은 대가인 것 같다.*

> *다리가 아팠지만, 친구들을 만나기 위해 서두르고 있었다. 그래서 몸을 일으켜 계속 갔다. 더 걸을수록 고통이 심해졌다. 처음에는 충격이라고 생각했지만, 뭔가 잘못되었다는 것을 빠르게 깨달았다.*

> *그럼에도 불구하고 바로 서둘러 갔다. 도착했을 때는 고통이 극심했다. 너무 산만해서 좋은 밤을 보내지 못했다. 아침에 의사에게 가서 정강이뼈가 골절되었다는 것을 알았다. 고통을 느꼈을 때 멈췄다면, 그 위를 걸음으로써 야기한 많은 추가 손상을 예방할 수 있었을 것이다. 아마도 내 인생 최악의 다음 날 아침이었다.*

너무 많은 프로그래머들이 제 재앙적인 밤처럼 코드를 작성합니다.

*에러, 무슨 에러? 심각하지 않을 거야. 정말이야. 무시할 수 있어.* 이것은 견고한 코드를 위한 성공적인 전략이 아닙니다. 사실, 그냥 순전히 게으름입니다. (잘못된 종류의.) 코드에서 에러가 얼마나 가능성이 낮다고 생각하든, 항상 확인해야 하고, 항상 처리해야 합니다. 매번. 그렇게 하지 않으면 시간을 절약하는 것이 아닙니다: 미래를 위한 잠재적 문제들을 저장하고 있는 것입니다.

우리는 다음을 포함한 여러 방법으로 코드에서 에러를 보고합니다:

- **리턴 코드**는 "작동하지 않았다"는 의미로 함수의 결과값으로 사용될 수 있습니다. 에러 리턴 코드는 무시하기가 너무 쉽습니다. 문제를 강조하는 코드에서 아무것도 볼 수 없을 것입니다. 실제로, 일부 표준 C 함수의 리턴 값을 무시하는 것이 표준 관행이 되었습니다. printf의 리턴 값을 얼마나 자주 확인하십니까?

- **errno**는 이상한 C의 일탈로, 에러를 신호하기 위해 설정되는 별도의 전역 변수입니다. 무시하기 쉽고, 사용하기 어렵고, 모든 종류의 불쾌한 문제들로 이어집니다 — 예를 들어, 여러 스레드가 같은 함수를 호출할 때 무슨 일이 일어날까요? 일부 플랫폼은 여기서 고통으로부터 당신을 보호해줍니다; 다른 플랫폼들은 그렇지 않습니다.

- **예외**는 에러를 신호하고 처리하는 더 구조화된 언어 지원 방법입니다. 그리고 그것들을 무시할 수는 없습니다. 아니면 무시할 수 있을까요? 저는 이런 코드를 많이 봤습니다:

```
try {
    // ...do something...
}
catch (...) {} // ignore errors
```

이 끔찍한 구조의 구원의 은총은 당신이 도덕적으로 의심스러운 일을 하고 있다는 사실을 강조한다는 것입니다.

에러를 무시하고, 눈을 감고, 아무것도 잘못되지 않았다고 가정한다면, 큰 위험을 감수하게 됩니다. 제 다리가 즉시 걷기를 멈췄을 때보다 더 나쁜 상태가 된 것처럼, 관계없이 계속 밀고 나가는 것은 매우 복잡한 실패로 이어질 수 있습니다. 가장 빠른 기회에 문제를 처리하세요. 짧은 계정을 유지하세요.

에러를 처리하지 않으면 다음과 같은 결과를 낳습니다:

- **부서지기 쉬운 코드.** 흥미롭고 찾기 어려운 버그들로 가득한 코드.
- **불안전한 코드.** 크래커들은 종종 소프트웨어 시스템에 침입하기 위해 잘못된 에러 처리를 이용합니다.
- **불량한 구조.** 지속적으로 처리하기 지루한 에러들이 코드에서 나온다면, 아마도 불량한 인터페이스를 가지고 있을 것입니다. 에러들이 덜 침입적이고 그것들의 처리가 덜 부담스럽도록 표현하세요.

코드의 모든 잠재적 에러를 확인해야 하는 것처럼, 인터페이스에서 모든 잠재적으로 에러가 있는 조건들을 노출해야 합니다. 서비스가 항상 작동할 것이라고 가정하며 그것들을 숨기지 마세요.

왜 에러를 확인하지 않을까요? 여러 일반적인 변명이 있습니다. 이 중 어느 것에 동의하십니까? 각각을 어떻게 반박하겠습니까?

- 에러 처리는 코드의 흐름을 어수선하게 만들어, 읽기 어렵게 하고, "정상적인" 실행 흐름을 발견하기 어렵게 합니다.
- 추가 작업이고 마감일이 다가오고 있습니다.
- 이 함수 호출이 *절대* 에러를 리턴하지 않을 것을 압니다 (printf는 항상 작동하고, malloc은 항상 새 메모리를 리턴합니다 — 실패한다면 더 큰 문제가 있는 것입니다...).
- 단지 장난감 프로그램이고, 운영 수준으로 작성될 필요가 없습니다.

[Pete Goodliffe](http://programmer.97things.oreilly.com/wiki/index.php/Pete_Goodliffe)가 작성함.