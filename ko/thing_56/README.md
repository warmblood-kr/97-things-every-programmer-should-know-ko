# 보이지 않는 것을 더 보이게 만들어라

비가시성의 많은 측면들이 소프트웨어 원칙으로서 당연히 칭찬받습니다. 우리의 용어는 비가시성 은유가 풍부합니다 — 메커니즘 투명성과 정보 은닉을 예로 들 수 있습니다. 소프트웨어와 그것을 개발하는 과정은 Douglas Adams의 말을 빌리면, *대부분 보이지 않을* 수 있습니다:

- 소스 코드는 타고난 존재감도, 타고난 행동도 없고, 물리 법칙에 순종하지도 않습니다. 에디터에 로드할 때는 보이지만, 에디터를 닫으면 사라집니다. 너무 오래 생각하면, 아무도 듣지 않는 상황에서 쓰러지는 나무처럼, 그것이 정말 존재하는지 궁금해지기 시작합니다.
- 실행 중인 애플리케이션은 존재감과 행동을 갖지만, 그것이 만들어진 소스 코드에 대해서는 아무것도 드러내지 않습니다. Google의 홈페이지는 기분 좋게 최소한입니다; 그 뒤에서 벌어지는 일들은 분명히 상당할 것입니다.
- 90% 완료했고 마지막 10%를 디버깅하려고 끝없이 발버둥치고 있다면 90% 완료한 것이 아닙니다, 그렇죠? 버그 수정은 진전이 아닙니다. 디버깅하라고 돈을 받는 것이 아닙니다. 디버깅은 낭비입니다. 낭비를 더 보이게 만들어서 그것이 무엇인지 볼 수 있고 애초에 그것을 만들지 않으려고 노력하는 것에 대해 생각하기 시작할 수 있게 하는 것이 좋습니다.
- 프로젝트가 겉보기에 순조롭게 진행되고 있다가 일주일 후에 6개월 늦어진다면 문제가 있는 것인데, 가장 큰 문제는 아마도 6개월 늦어진 것이 아니라 6개월의 지연을 숨길 만큼 강력한 비가시성 보호막일 것입니다! 보이는 진전의 부족은 진전의 부족과 같은 의미입니다.

비가시성은 위험할 수 있습니다. 생각을 묶을 수 있는 구체적인 것이 있을 때 더 명확하게 생각할 수 있습니다. 볼 수 있고 지속적으로 변화하는 것을 볼 수 있을 때 더 잘 관리할 수 있습니다:

- 단위 테스트 작성은 코드 단위가 단위 테스트하기 얼마나 쉬운지에 대한 증거를 제공합니다. 코드가 보여주기를 바라는 개발적 품질들의 존재(또는 부재)를 드러내는 데 도움이 됩니다; 낮은 결합도와 높은 응집도 같은 품질들 말입니다.
- 단위 테스트 실행은 코드의 행동에 대한 증거를 제공합니다. 애플리케이션이 보여주기를 바라는 런타임 품질들의 존재(또는 부재)를 드러내는 데 도움이 됩니다; 견고함과 정확성 같은 품질들 말입니다.
- 게시판과 카드 사용은 진전을 보이고 구체적으로 만듭니다. 작업들을 숨겨진 프로젝트 관리 도구에 대한 참조 없이, 그리고 허구적인 상태 보고서를 위해 프로그래머들을 쫓아다닐 필요 없이 *시작 안 함*, *진행 중*, 또는 *완료*로 볼 수 있습니다.
- 점진적 개발 수행은 개발 증거의 빈도를 증가시켜 개발 진전(또는 그것의 부족)의 가시성을 증가시킵니다. 릴리스 가능한 소프트웨어의 완성은 현실을 드러냅니다; 추정치는 그렇지 않습니다.

정기적으로 보이는 충분한 증거와 함께 소프트웨어를 개발하는 것이 최선입니다. 가시성은 진전이 진짜이고 환상이 아니며, 의도적이고 의도하지 않은 것이 아니며, 반복 가능하고 우발적이지 않다는 확신을 줍니다.

[Jon Jagger](http://programmer.97things.oreilly.com/wiki/index.php/Jon_Jagger)가 작성함.