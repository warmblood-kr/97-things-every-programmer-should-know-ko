# 예시를 사용하여 작은 함수를 작성하라

우리는 올바른 코드를 작성하고 그것이 올바르다는 증거를 손에 가지고 있고 싶어합니다. 함수의 "크기"에 대해 생각하는 것이 두 문제 모두에 도움이 될 수 있습니다. 함수를 구현하는 코드의 양이라는 의미에서가 아니라 — 비록 그것도 흥미롭긴 하지만 — 오히려 우리 코드가 나타내는 수학적 함수의 크기 말입니다.

예를 들어, 바둑 게임에서 플레이어의 돌이 상대방에 의해 잡힐 수 있는 *아타리*라고 불리는 조건이 있습니다: 인접한 두 개 이상의 자유 공간(*활로*라고 불림)을 가진 돌은 아타리에 있지 않습니다. 돌이 얼마나 많은 활로를 가지고 있는지 세는 것은 까다로울 수 있지만, 그것이 알려져 있다면 아타리를 결정하는 것은 쉽습니다. 우리는 다음과 같은 함수를 작성하는 것으로 시작할 수 있습니다:

```
boolean atari(int libertyCount)
    libertyCount < 2
```

이것은 보이는 것보다 더 큽니다. 수학적 함수는 집합으로 이해될 수 있는데, 그것의 정의역(여기서는 `int`)과 치역(여기서는 `boolean`)인 집합들의 데카르트 곱의 어떤 부분집합입니다. 그 값들의 집합들이 Java에서와 같은 크기라면 집합 `int×boolean`에 `2L*(Integer.MAX_VALUE+(-1L*Integer.MIN_VALUE)+1L)` 또는 8,589,934,592개의 구성원이 있을 것입니다. 이것들의 절반이 우리 함수인 부분집합의 구성원이므로, 우리 함수가 올바르다는 완전한 증거를 제공하려면 대략 4.3×10<sup>9</sup>개의 예시를 확인해야 할 것입니다.

이것이 테스트가 버그의 부재를 증명할 수 없다는 주장의 본질입니다. 하지만 테스트는 기능의 존재를 보여줄 수 있습니다. 그러나 여전히 크기의 문제가 있습니다.

문제 영역이 우리를 도와줍니다. 바둑의 특성상 돌의 활로 수는 어떤 int가 아니라 정확히 {1,2,3,4} 중 하나입니다. 그래서 우리는 대안적으로 다음과 같이 작성할 수 있습니다:

```
LibertyCount = {1,2,3,4} 
boolean atari(LibertyCount libertyCount)
    libertyCount == 1
```

이것은 훨씬 더 다루기 쉽습니다: 계산된 함수는 이제 최대 8개의 구성원을 가진 집합입니다. 사실, 4개의 확인된 예시가 함수가 올바르다는 완전한 확실성의 증거를 구성할 것입니다. 이것이 네이티브 타입보다는 문제 영역과 밀접하게 관련된 타입을 사용하여 프로그램을 작성하는 것이 좋은 아이디어인 한 가지 이유입니다. 도메인에서 영감을 받은 타입을 사용하는 것은 종종 우리의 함수들을 훨씬 더 작게 만들 수 있습니다. 그런 타입들이 무엇이어야 하는지 알아내는 한 가지 방법은 함수를 작성하기 전에 문제 영역 용어로 확인할 예시들을 찾는 것입니다.

[Keith Braithwaite](http://programmer.97things.oreilly.com/wiki/index.php/Keith_Braithwaite)가 작성함.