# 마우스를 내려놓고 키보드에서 떨어져라

몇 시간 동안 어떤 까다로운 문제에 집중했는데 해결책이 보이지 않습니다. 그래서 다리를 뻗으러 일어나거나, 자판기에 가려고 하는데, 돌아오는 길에 갑자기 답이 명백해집니다.

이 시나리오가 익숙하게 들리나요? 왜 그런 일이 일어나는지 궁금해한 적이 있나요? 트릭은 코딩하고 있을 때, 뇌의 논리적 부분이 활성화되고 창의적인 부분이 차단된다는 것입니다. 논리적 부분이 휴식을 취할 때까지는 아무것도 당신에게 제시할 수 없습니다.

실제 사례가 하나 있습니다: 저는 레거시 코드를 정리하고 있었는데 '흥미로운' 메서드를 발견했습니다. 그것은 문자열이 *hh:mm:ss xx* 형식을 사용해서 유효한 시간을 포함하는지 검증하도록 설계되어 있었는데, 여기서 *hh*는 시간, *mm*은 분, *ss*는 초를 나타내고, *xx*는 *AM* 또는 *PM*입니다.

메서드는 다음 코드를 사용해서 (시간을 나타내는) 두 문자를 숫자로 변환하고, 그것이 적절한 범위 내에 있는지 검증했습니다:

```
try {
    Integer.parseInt(time.substring(0, 2));
} catch (Exception x) {
    return false;
}

if (Integer.parseInt(time.substring(0, 2)) > 12) {
    return false;
}
```

같은 코드가 분과 초를 테스트하기 위해 문자 오프셋과 상한을 적절히 변경해서 두 번 더 나타났습니다. 메서드는 AM과 PM을 확인하는 다음 줄들로 끝났습니다:

```
if (!time.substring(9, 11).equals("AM") &
    !time.substring(9, 11).equals("PM")) {
    return false;
}
```

이 일련의 비교들 중 어느 것도 실패하지 않아서 false를 반환하지 않으면, 메서드는 true를 반환했습니다.

앞의 코드가 장황하고 따라가기 어려워 보인다면, 걱정하지 마세요. 저도 그렇게 생각했습니다 — 이는 정리할 가치가 있는 것을 발견했다는 의미였습니다. 저는 그것을 리팩터링하고 여전히 작동하는지 확인하기 위해 몇 개의 단위 테스트를 작성했습니다.

끝냈을 때, 저는 결과에 만족했습니다. 새 버전은 읽기 쉬웠고, 크기는 절반이었으며, 원래 코드가 시간, 분, 초의 상한만 테스트했기 때문에 더 정확했습니다.

다음날 출근 준비를 하면서, 아이디어가 머리에 떠올랐습니다: 정규 표현식을 사용해서 문자열을 검증하는 건 어떨까? 몇 분 타이핑한 후에, 단 한 줄의 코드로 작동하는 구현을 갖게 되었습니다. 여기 있습니다:

```
public static boolean validateTime(String time) {
    return time.matches("(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] ([AP]M)");
}
```

이 이야기의 요점은 제가 결국 30줄 이상의 코드를 단 한 줄로 바꿨다는 것이 아닙니다. 요점은 컴퓨터에서 떨어질 때까지는, 제 첫 번째 시도가 문제에 대한 최선의 해결책이라고 생각했다는 것입니다.

그래서 다음에 까다로운 문제에 부딪히면, 스스로에게 호의를 베푸세요. 문제를 정말로 이해했다면 뇌의 창의적인 부분을 포함하는 일을 하러 가세요 — 문제를 스케치하거나, 음악을 듣거나, 아니면 그냥 밖에서 산책하세요. 때로는 문제를 해결하기 위해 할 수 있는 최선의 일은 마우스를 내려놓고 키보드에서 떨어지는 것입니다.

[BurkHufnagel](http://programmer.97things.oreilly.com/wiki/index.php/BurkHufnagel)이 작성함.