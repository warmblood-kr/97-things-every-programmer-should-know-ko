# 당신의 한계를 알아라

> *"사람은 자신의 한계를 알아야 한다." — 더티 해리*

당신의 자원은 제한되어 있습니다. 당신은 지식, 기술, 도구를 최신 상태로 유지하는 데 필요한 시간과 돈을 포함하여 작업을 수행하는 데 제한된 시간과 돈만을 가지고 있습니다. 당신은 제한적으로만 열심히, 빠르게, 똑똑하게, 그리고 오래 일할 수 있습니다. 당신의 도구는 제한적으로만 강력합니다. 당신의 대상 머신들은 제한적으로만 강력합니다. 그러므로 당신은 자원의 한계를 존중해야 합니다.

그런 한계를 어떻게 존중할까요? 자신을 알고, 사람들을 알고, 예산을 알고, 자료를 알아야 합니다. 특히, 소프트웨어 엔지니어로서 데이터 구조와 알고리즘의 공간 및 시간 복잡도와, 시스템의 아키텍처 및 성능 특성을 알아야 합니다. 당신의 일은 소프트웨어와 시스템의 최적 결합을 만드는 것입니다.

공간과 시간 복잡도는 함수 *O(f(n))*로 주어지는데, 여기서 n이 입력의 크기와 같을 때 n이 무한대로 증가할 때 필요한 점근적 공간 또는 시간입니다. *f(n)*에 대한 중요한 복잡도 클래스들은 *ln(n)*, *n*, *n ln(n)*, *n<sup>e</sup>*, *e<sup>n</sup>*을 포함합니다. 이런 함수들을 그래프로 그려보면 명확히 보이듯이, *n*이 커질수록 *O(ln(n))*은 *O(n)*이나 *O(n ln(n))*보다 훨씬 작고, 이들은 *O(n<sup>e</sup>)*나 *O(e<sup>n</sup>)*보다 훨씬 작습니다. Sean Parent가 말하듯이, 달성 가능한 n에 대해 모든 복잡도 클래스들은 거의 상수, 거의 선형, 또는 거의 무한대에 해당합니다.

![](http://programmer.97things.oreilly.com/wiki/images/c/c0/Clearly.jpeg)

|              | 접근 시간        |   용량 |
|--------------|-----------------:| ----------:|
| 레지스터     |  < 1 ns          |        64b |
| 캐시 라인   |                  |        64B |
| L1 캐시     |  1 ns            | 64 KB      |
| L2 캐시     |  4 ns            | 8 MB       |
| RAM          | 20 ns            | 32 GB      |
| 디스크         | 10 ms            | 10 TB      |
| LAN          | 20 ms            | > 1 PB     |
| 인터넷     | 100 ms           | > 1 ZB     |

복잡도 분석은 추상 머신 관점에서 이루어지지만, 소프트웨어는 실제 머신에서 실행됩니다. 현대 컴퓨터 시스템은 언어 런타임, 운영 체제, CPU, 캐시 메모리, 임의 접근 메모리, 디스크 드라이브, 네트워크를 포함한 물리적 및 가상 머신의 계층으로 구성됩니다. 첫 번째 표는 전형적인 네트워크 서버의 임의 접근 시간과 저장 용량의 한계를 보여줍니다.

용량과 속도가 여러 자릿수만큼 변한다는 것을 주목하세요. 캐싱과 선행 읽기가 이런 변화를 숨기기 위해 시스템의 모든 수준에서 많이 사용되지만, 접근이 예측 가능할 때만 작동합니다. 캐시 미스가 빈번하면 시스템이 스래싱할 것입니다. 예를 들어, 하드 드라이브의 모든 바이트를 무작위로 검사하는 것은 32년이 걸릴 수 있습니다. 심지어 RAM의 모든 바이트를 무작위로 검사하는 것도 11분이 걸릴 수 있습니다. 무작위 접근은 예측 가능하지 않습니다. 무엇이 예측 가능할까요? 그것은 시스템에 따라 다르지만, 최근에 사용된 항목들을 다시 접근하고 항목들을 순차적으로 접근하는 것은 보통 승리입니다.

알고리즘과 데이터 구조는 캐시를 얼마나 효과적으로 사용하는지에서 차이가 납니다. 예를 들어:
- 선형 검색은 선행 읽기를 잘 활용하지만, *O(n)* 비교가 필요합니다.
- 정렬된 배열의 이진 검색은 단지 *O(log(n))* 비교만 필요합니다.
- van Emde Boas 트리의 검색은 *O(log(n))*이고 캐시 무관(cache-oblivious)입니다.

|요소들 | 검색 시간 (ns)|       |         |
|:--------|-----------:|-----------:|--------:|
|         | **선형** | **이진** |	**vEB** |
| 8       | 50         | 90         | 40      |
| 64      | 180        | 150        | 70      |
| 512     | 1200       | 230        | 100     |
| 4096    | 17000      | 320        | 160     |

어떻게 선택할까요? 최종 분석에서는 측정으로. 두 번째 표는 이 세 가지 방법을 통해 64비트 정수 배열을 검색하는 데 필요한 시간을 보여줍니다. 제 컴퓨터에서:
- 선형 검색은 작은 배열에서는 경쟁력이 있지만, 더 큰 배열에서는 지수적으로 집니다.
- van Emde Boas는 예측 가능한 접근 패턴 덕분에 압도적으로 승리합니다.

> *"돈을 내고 선택하는 거야." — [Punch](http://www.nytimes.com/1988/02/28/magazine/on-language-you-pays-yer-money.html?pagewanted=all)*

[Greg Colvin](http://programmer.97things.oreilly.com/wiki/index.php/Greg_Colvin)이 작성함.