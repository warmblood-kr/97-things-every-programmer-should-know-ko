# 정확하고 구체적으로 테스트하라

코드 단위의 특정 구현의 부수적 동작을 테스트하기보다는 원하는 필수 동작을 테스트하는 것이 중요합니다. 하지만 이것을 모호한 테스트에 대한 변명으로 받아들이거나 오해해서는 안 됩니다. 테스트는 정확하*고* 정확해야 합니다.

시도되고, 테스트되고, 테스트의 고전인 정렬 루틴은 설명적인 예시를 제공합니다. 정렬 알고리즘을 구현하는 것이 프로그래머에게 매일의 작업은 아니지만, 정렬은 대부분의 사람들이 그것에서 무엇을 기대하는지 안다고 믿을 정도로 친숙한 아이디어입니다. 하지만 이런 무심한 친숙함은 특정 가정들을 넘어서 보는 것을 더 어렵게 만들 수 있습니다.

프로그래머들에게 "무엇을 테스트하겠습니까?"라고 물었을 때, 단연코 가장 일반적인 응답은 "정렬의 결과는 정렬된 요소 시퀀스입니다"입니다. 이것이 사실이긴 하지만, 전체 진실은 아닙니다. 더 정확한 조건을 위해 촉구받았을 때, 많은 프로그래머들은 결과 시퀀스가 원본과 같은 길이여야 한다고 추가합니다. 정확하긴 하지만, 이것도 여전히 충분하지 않습니다. 예를 들어, 다음 시퀀스가 주어졌을 때:

```
3 1 4 1 5 9
```

다음 시퀀스는 비내림차순으로 정렬되고 원본 시퀀스와 같은 길이를 갖는다는 사후조건을 만족합니다:

```
3 3 3 3 3 3
```

사양을 만족하긴 하지만, 이것은 또한 확실히 의도된 것이 아닙니다! 이 예시는 실제 프로덕션 코드에서 가져온 오류(다행히 릴리스되기 전에 잡힌)를 기반으로 한 것으로, 키 입력의 간단한 실수나 순간적인 이성의 실수가 주어진 배열의 첫 번째 요소로 전체 결과를 채우는 정교한 메커니즘으로 이어졌습니다.

완전한 사후조건은 결과가 정렬되고 원본 값들의 순열을 보유한다는 것입니다. 이것은 필요한 동작을 적절히 제약합니다. 결과 길이가 입력 길이와 같다는 것은 자연스럽게 따라오므로 다시 말할 필요가 없습니다.

설명된 방식으로 사후조건을 명시하는 것조차 좋은 테스트를 제공하기에는 충분하지 않습니다. 좋은 테스트는 읽기 가능해야 합니다. 그것은 이해할 수 있고 당신이 그것이 올바른지(또는 아닌지) 쉽게 볼 수 있을 정도로 단순해야 합니다. 시퀀스가 정렬되었는지 확인하고 한 시퀀스가 다른 시퀀스의 값들의 순열을 포함하는지 확인하는 코드가 이미 있지 않다면, 테스트 코드가 테스트 대상 코드보다 더 복잡할 가능성이 꽤 높습니다. 토니 호어가 관찰한 바와 같이:

> 소프트웨어 설계를 구성하는 두 가지 방법이 있습니다: 한 가지 방법은 *명백히* 결함이 없을 정도로 단순하게 만드는 것이고 다른 방법은 명백한 결함이 없을 정도로 복잡하게 만드는 것입니다.

구체적인 예시를 사용하는 것은 이런 우발적 복잡성과 사고의 기회를 제거합니다. 예를 들어, 다음 시퀀스가 주어졌을 때:

```
3 1 4 1 5 9
```

정렬의 결과는 다음과 같습니다:

```
1 1 3 4 5 9
```

다른 답은 안 됩니다. 대체품을 받아들이지 마세요.

구체적인 예시는 접근 가능하고 모호하지 않은 방식으로 일반적인 동작을 설명하는 데 도움이 됩니다. 빈 컬렉션에 항목을 추가한 결과는 단순히 그것이 비어있지 않다는 것이 아닙니다: 컬렉션이 이제 단일 항목을 가진다는 것입니다. 그리고 보유된 단일 항목이 추가된 항목이라는 것입니다. 두 개 이상의 항목들도 비어있지 않다는 자격을 갖춥니다. 그리고 그것도 틀릴 것입니다. 다른 값의 단일 항목도 틀릴 것입니다. 테이블에 행을 추가한 결과는 단순히 테이블이 한 행 더 크다는 것이 아닙니다. 그것은 또한 행의 키가 추가된 행을 복구하는 데 사용될 수 있다는 것을 수반합니다. 기타 등등.

동작을 명시할 때, 테스트들은 단순히 정확하기만 해서는 안 됩니다: 그들은 또한 정확해야 합니다.

[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)가 작성함.