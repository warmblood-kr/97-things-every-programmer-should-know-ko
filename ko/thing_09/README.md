# 다른 사람을 탓하기 전에 먼저 당신의 코드를 확인하라

개발자들 — 우리 모두가! — 은 종종 자신의 코드가 망가졌다는 사실을 믿기 어려워합니다. 그럴 리가 없으니, 한 번만은 컴파일러가 망가진 게 틀림없다고 생각하죠.

하지만 실제로는 컴파일러, 인터프리터, 운영체제, 애플리케이션 서버, 데이터베이스, 메모리 관리자, 또는 다른 시스템 소프트웨어의 버그로 인해 코드가 망가지는 것은 매우(매우) 드문 일입니다. 물론 이런 버그들은 존재하지만, 우리가 믿고 싶어하는 것보다 훨씬 드뭅니다.

한 번은 컴파일러 버그로 인해 루프 변수가 최적화로 인해 사라지는 진짜 문제를 겪은 적이 있었지만, 컴파일러나 운영체제에 버그가 있다고 상상한 횟수는 훨씬 더 많았습니다. 그 과정에서 많은 시간과 지원 시간, 그리고 관리 시간을 낭비했으며, 결국 제 실수였음이 밝혀질 때마다 조금씩 바보같다고 느꼈습니다.

도구가 널리 사용되고, 성숙하며, 다양한 기술 스택에서 사용된다고 가정한다면, 품질을 의심할 이유는 거의 없습니다. 물론 도구가 초기 릴리스이거나, 전 세계적으로 소수의 사람들만 사용하거나, 거의 다운로드되지 않는 버전 0.1의 오픈 소스 소프트웨어라면, 소프트웨어를 의심할 만한 충분한 이유가 있을 수 있습니다. (마찬가지로, 상용 소프트웨어의 알파 버전도 의심스러울 수 있습니다.)

컴파일러 버그가 얼마나 드문지를 고려할 때, 컴파일러가 틀렸다는 것을 증명하는 것보다는 코드에서 오류를 찾는 데 시간과 에너지를 투자하는 것이 훨씬 낫습니다. 모든 일반적인 디버깅 조언이 적용되므로, 문제를 격리하고, 호출을 스텁으로 만들고, 테스트로 둘러싸세요. 호출 규약, 공유 라이브러리, 버전 번호를 확인하고; 다른 사람에게 설명해보고; 스택 손상과 변수 타입 불일치를 주의깊게 살펴보세요. 다른 머신과 디버그 및 릴리스 같은 다른 빌드 구성에서 코드를 시도해보세요.

자신의 가정과 다른 사람들의 가정을 의심해보세요. 다른 벤더의 도구들은 서로 다른 가정을 내장하고 있을 수 있습니다 — 같은 벤더의 다른 도구들도 마찬가지일 수 있습니다.

다른 사람이 당신이 재현할 수 없는 문제를 보고할 때는, 가서 그들이 무엇을 하고 있는지 보세요. 그들이 당신이 생각해보지 못한 일을 하고 있거나 다른 순서로 뭔가를 하고 있을 수 있습니다.

개인적인 규칙으로, 찾아낼 수 없는 버그가 있고 컴파일러 문제라고 생각하기 시작한다면, 스택 손상을 찾아볼 때입니다. 특히 추적 코드를 추가했을 때 문제가 이리저리 움직인다면 더욱 그렇습니다.

멀티스레드 문제는 머리를 희끗희끗하게 만들고 기계에 소리를 지르게 만드는 또 다른 버그의 원천입니다. 단순한 코드를 선호하라는 모든 권장사항은 시스템이 멀티스레드일 때 배가됩니다. 디버깅과 단위 테스트는 이런 버그를 일관성 있게 찾는 데 의존할 수 없으므로, 설계의 단순함이 가장 중요합니다.

따라서 컴파일러를 탓하기 전에, 셜록 홈즈의 조언을 기억하세요: "불가능한 것을 제거하면, 아무리 개연성이 없더라도 남는 것이 진실이어야 한다." 그리고 이를 더크 젠틀리의 말보다 선호하세요: "개연성이 없는 것을 제거하면, 아무리 불가능하더라도 남는 것이 진실이어야 한다."

[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)가 작성함.