# 함수형 프로그래밍 원칙을 적용하라

함수형 프로그래밍은 최근 주류 프로그래밍 커뮤니티에서 재조명을 받았습니다. 그 이유 중 하나는 함수형 패러다임의 *창발하는 속성(emergent properties)*이 우리 산업의 다중 코어(multi-core)로의 전환이 가져오는 도전 과제를 해결하는 데 잘 어울리기 때문입니다. 그러나 그것이 중요한 응용은 맞지만, 이 글에서 당신에게 *함수형 프로그래밍을 알아야 한다*고 경고하는 이유는 아닙니다.

함수형 프로그래밍 패러다임에 대한 숙달은 다른 맥락에서 작성하는 코드의 품질을 크게 향상시킬 수 있습니다. 함수형 패러다임을 깊이 이해하고 적용한다면, 당신의 설계는 훨씬 더 높은 정도의 *참조 투명성(referential transparency)*을 나타낼 것입니다.

참조 투명성은 매우 바람직한 속성입니다: 이는 함수가 호출되는 위치와 시간에 관계없이 같은 입력이 주어질 때 일관되게 같은 결과를 산출함을 의미합니다. 즉, 함수 평가가 가변 상태(mutable state)의 부작용에 덜 의존하게 되며, 이상적으로는 전혀 의존하지 않아야 합니다.

명령형 코드에서 결함의 주요 원인은 가변 변수(mutable variables) 때문입니다. 이 글을 읽는 모든 사람은 특정 상황에서 어떤 값이 예상과 다르게 나타나는 이유를 조사해본 적이 있을 것입니다. 가시성 의미론(visibility semantics)은 이러한 악성 결함을 완화하는 데 도움을 줄 수 있지만, 그들의 진정한 원인은 지나친 가변성을 사용하는 설계에서 오는 것일 수 있습니다.

그리고 이와 관련하여 산업계에서 많은 도움을 받지는 못합니다. 객체 지향(object orientation) 소개는 그러한 설계를 암묵적으로 촉진합니다. 왜냐하면 상대적으로 장기 생존 객체들이 서로에 대해 변조자(mutable methods)를 호출하는 예시를 자주 보여주기 때문입니다. 하지만, 정교한 테스트 주도 설계(test-driven design)를 통해, 특히 ["Mock Roles, not Objects"](http://www.jmock.org/oopsla2004.pdf)라는 원칙을 준수할 때, 불필요한 가변성을 제거하는 설계를 할 수 있습니다.

결과적으로 이러한 설계는 일반적으로 더 나은 책임 배분(responsibility allocation)을 갖고 있으며, 인수(arguments)를 전달받아 작동하는 더 많고 작은 함수로 구성됩니다. 이는 가변적인 멤버 변수를 참조하는 것보다 결함을 줄이고, 이러한 설계에서 불량 값이 도입된 위치를 찾기가 더 쉽기 때문에 디버깅이 더 간단합니다. 이는 훨씬 높은 정도의 참조 투명성으로 이어지며, 이러한 계산 모델이 일반적인 함수형 프로그래밍 언어를 배우는 것만큼 이 아이디어를 깊이 내재화하는 방법은 없습니다.

물론 이 접근 방식이 모든 상황에서 최적의 결과를 내는 것은 아닙니다. 예를 들어, 객체 지향 시스템에서는 이 스타일이 사용자 인터페이스 개발(user-interface development)보다 도메인 모델 개발(domain model development)에서 더 나은 결과를 가져오는 경우가 많습니다.

함수형 프로그래밍 패러다임을 마스터하여 다른 도메인에 배운 교훈을 신중하게 적용할 수 있도록 하세요. 당신의 객체 시스템은 (하나의 예로) 참조 투명성의 장점을 가지고 있으며, 많은 사람들이 믿게 하려는 것보다 기능적 대응체와 훨씬 더 가까워질 것입니다. 사실, 어떤 사람들은 함수형 프로그래밍과 객체 지향의 정점이 *서로의 반영(reflection)[^1]일 뿐*이며, 컴퓨테이셔널의 음과 양(yin and yang)의 형태라고 주장하기도 합니다.

[에드워드 가슨](http://programmer.97things.oreilly.com/wiki/index.php/Edward_Garson)이 씀.

[^1]: 거울처럼 서로 비춰져 맺혀진 상이지만, 본질적으로는 유사하다는 것을 의미합니다 (역자 주)
