# 하나의 바이너리

빌드가 코드의 일부분을 다시 작성해서 각 타겟 환경을 위한 커스텀 바이너리를 생성하는 여러 프로젝트를 보았습니다. 이것은 항상 일을 필요 이상으로 복잡하게 만들고, 팀이 각 설치에서 일관된 버전을 갖지 못할 위험을 도입합니다. 최소한 그것은 소프트웨어의 여러 개의 거의 동일한 복사본을 빌드하는 것을 포함하며, 각각은 올바른 장소에 배포되어야 합니다. 그것은 필요 이상으로 많은 움직이는 부품을 의미하며, 이는 실수할 기회가 더 많다는 것을 의미합니다.

한때 모든 속성 변경이 전체 빌드 사이클을 위해 체크인되어야 하는 팀에서 일한 적이 있어서, 테스터들이 사소한 조정이 필요할 때마다 기다려야 했습니다(빌드 시간도 너무 오래 걸렸다고 언급했나요?). 또한 시스템 관리자들이 프로덕션을 위해 처음부터 다시 빌드하기를 고집하는(우리가 사용한 것과 같은 스크립트를 사용해서) 팀에서 일한 적도 있는데, 이는 프로덕션의 버전이 테스트를 거친 것이라는 증거가 없다는 것을 의미했습니다. 등등.

규칙은 간단합니다: *릴리스 파이프라인의 모든 단계를 통해 식별하고 승진시킬 수 있는 단일 바이너리를 빌드하세요.* 환경별 세부사항은 환경에 보관하세요. 이것은 예를 들어, 컴포넌트 컨테이너에, 알려진 파일에, 또는 경로에 보관하는 것을 의미할 수 있습니다.

팀이 코드를 변경하는 빌드를 갖고 있거나 모든 타겟 설정을 코드와 함께 저장한다면, 그것은 아무도 애플리케이션의 핵심인 기능과 플랫폼별 기능을 분리할 만큼 충분히 신중하게 설계를 생각해보지 않았다는 것을 시사합니다. 또는 더 나쁠 수도 있습니다: 팀이 무엇을 해야 할지 알지만 변화를 만들기 위한 노력의 우선순위를 매길 수 없습니다.

물론, 예외가 있습니다: 현저히 다른 자원 제약을 갖는 타겟들을 위해 빌드하고 있을 수도 있지만, 그것은 "데이터베이스에서 화면으로 그리고 다시 돌아가는" 애플리케이션을 작성하는 우리 대부분에게는 적용되지 않습니다. 대안적으로, 지금 당장 고치기에는 너무 어려운 레거시 혼란과 함께 살고 있을 수도 있습니다. 그런 경우에는, 점진적으로 움직여야 합니다 — 하지만 가능한 한 빨리 시작하세요.

그리고 한 가지 더: 환경 정보도 버전 관리하세요. 환경 설정을 깨뜨리고 무엇이 변경되었는지 알아낼 수 없는 것보다 더 나쁜 것은 없습니다. 환경 정보는 코드와 별도로 버전 관리되어야 하는데, 그것들이 다른 속도로 그리고 다른 이유로 변경될 것이기 때문입니다. 일부 팀들은 이것을 위해 분산 버전 제어 시스템을(bazaar와 git 같은) 사용하는데, 그것들이 프로덕션 환경에서 만들어진 변경사항들을 — 필연적으로 일어나는 것처럼 — 리포지토리로 다시 푸시하는 것을 더 쉽게 만들기 때문입니다.

[Steve Freeman](http://programmer.97things.oreilly.com/wiki/index.php/Steve_Freeman)이 작성함.